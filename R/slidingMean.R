#' Data smoothing for peptide microarray.
#' 
#' This function applies a sliding mean window to intensities to reduce noise 
#' generated by experimental variation, as well as take advantage of the overlapping
#' nature of array peptides to share signal.
#'  
#' @param peptideSet A \code{peptideSet}. The expression data for the peptides as 
#' well as annotations and ranges. The range information is required to run this function.
#' @param width A \code{numeric}. The width of the sliding window.
#' @param verbose A \code{logical}. If set to TRUE, progress information will be displayed.
#' @param split.by.space A \code{logical}. If TRUE, the peptides will be smoothed by
#' space (See details section below and \code{RangedData} for more information).
#' 
#' @details
#' Peptide membership in the sliding mean window is determined by its position and 
#' the width argument. Two peptides are in the same window if the difference in their 
#' positions is less than or equal to width/2. A peptide's position is taken to be 
#' position(peptideSet).
#' 
#' A peptide's intensity is replaced by the mean of all peptide intensities within 
#' the peptide's sliding mean window.
#' 
#' When split.by.space = TRUE, peptides are smoothed within groups defined by the 
#' space of the RangedData object occupying the featureRange slot of peptideSet. 
#' This is useful if, for example, spaces indicate peptides drawn from separate 
#' proteins that should not be smoothed together.
#' 
#' @return A \code{peptideSet} object with smoothed intensities.
#' 
#' @seealso \code{\link{summarizePeptides}}, \code{\link{normalizeArray}}
#' 
#' @author Gregory Imholte
#' 
#' @name slidingMean
#' @rdname slidingMean
#' @export
slidingMean <-function(peptideSet, width=5, verbose=FALSE, 
                       split.by.space=TRUE)
{
  if (class(peptideSet)!="peptideSet")
  {
    stop("peptideSet must be an object of class peptideSet")
  }
  if (preproc(peptideSet@experimentData)$transformation!="log" &
       preproc(peptideSet@experimentData)$transformation!="vsn") {
    stop("The probe measurements need to be log/vsn transformed!")
  }
  if (preproc(peptideSet@experimentData)$normalization=="none"){
    warning("You should probably normalize your data before using this function")
  }
  
  # Check whether user wishes to apply to multiple spaces 
  if (split.by.space & length(names(ranges(peptideSet))) > 1){
    oldrownames = rownames(ranges(peptideSet))
    s <- space(ranges(peptideSet))
    pSetList <- split(peptideSet, s)
    smoothedpSetList <- lapply(pSetList, function(set)
    {
      p <- position(set)
      o <- order(p)
      
      # reorder peptideSet by position order
      set <- set[o,]
      
      y <- exprs(set)
      p <- position(set)
      ny <- applySlidingMean(y, width, p)
      exprs(set) <- ny
      rownames(exprs(set)) <- rownames(y)
      
      set
    })
    
    # collect the sorted RangedData into a single RangedData object,
    # put back into peptideSet
    rdata = do.call("rbind", lapply(smoothedpSetList, ranges))
    peptideSet@featureRange = rdata
    
    # collect the separate smoothed intensities into a single expression
    # matrix, gather rownames
    exprs(peptideSet) = do.call("rbind", lapply(smoothedpSetList, exprs))
    rownames(exprs(peptideSet)) = do.call("c", 
      lapply(smoothedpSetList, function(x) rownames(exprs(x))))
  }
  
  else {
    if (length(names(ranges(peptideSet))) > 1)
      warning("smoothing multiple spaces together in peptideSet object")
    # This could be made more efficient with multicore
    p <- position(peptideSet)
    o <- order(p)
    ro <- order(o)
    
    y <- exprs(peptideSet)[o,]
    p <- position(peptideSet)[o]
    ny <- applySlidingMean(y, width, p)
    exprs(peptideSet) <- ny[ro,]
  }
  
  if (verbose) {
    cat("** Finished processing ",nrow(peptideSet)," probes on ",ncol(peptideSet)," arrays **\n");
  }
  peptideSet
}


applySlidingMean <- function(y, width, position)
{
  yn <- sapply(position, function(p) {
    p.window <- abs(position - p) <= width/2
    colMeans(y[p.window,,drop = FALSE])
  })
  yn <- t(yn)
  rownames(yn) <- rownames(y)
  return(yn)
}
